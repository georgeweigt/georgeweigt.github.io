<!doctype html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<title>Eigenmath Demo</title>
</head>
<body>

<script src="eigenmath.js"></script>

<table><tr><td>
<textarea id="stdin" rows="24" cols="80" style="font-family:courier;font-size:12pt">
-- Find r such that 7^r mod 15 = 1

-- See https://qiskit.org/textbook/ch-algorithms/shor.html

-- Uses experimental function 'rotate'

-- 7 mod 15 (from qiskit code)

U(psi,k) = rotate(
  psi,          -- ket
  C,k,X,8,      -- conditional not bit 8
  C,k,X,9,      -- conditional not bit 9
  C,k,X,10,     -- conditional not bit 10
  C,k,X,11,     -- conditional not bit 11
  C,k,S,10,11,  -- conditional swap bits 10 and 11
  C,k,S,9,10,   -- conditional swap bits 9 and 10
  C,k,S,8,9     -- conditional swap bits 8 and 9
)

-- initial state

psi = rotate(
  (1,0), -- ket
  X,8,   -- not bit 8
  H,0,   -- hadamard bit 0
  H,1,   -- hadamard bit 1
  H,2,   -- hadamard bit 2
  H,3,   -- hadamard bit 3
  H,4,   -- hadamard bit 4
  H,5,   -- hadamard bit 5
  H,6,   -- hadamard bit 6
  H,7    -- hadamard bit 7
)

-- U^(2^0) U^(2^1) U^(2^2) ... U^(2^7)

for(k,1,1,psi = U(psi,0))
for(k,1,2,psi = U(psi,1))
for(k,1,4,psi = U(psi,2))
for(k,1,8,psi = U(psi,3))
for(k,1,16,psi = U(psi,4))
for(k,1,32,psi = U(psi,5))
for(k,1,64,psi = U(psi,6))
for(k,1,128,psi = U(psi,7))

-- inverse QFT on bits 0-7

psi = rotate(psi,R,7)

-- probability

T = hadamard(psi,conj(psi))

-- high order 4 bits are don't care

P = zero(256)
for(j,1,256,P[j] = sum(k,0,15,T[256 k + j]))

-- display result in compact form

"First row is probability"
"Second row is observed phase"

n = 0
for(k,1,256,test(P[k],n=n+1))
test(n==0,n=1)
M = zero(2,n)
n = 1
for(k,1,256,test(P[k],do(M[1,n]=float(P[k]),M[2,n]=(k-1)/256,n=n+1)))
M
</textarea>
</td><td>
<button onclick="run()" style="font-size:20pt">Run</button>
</td></tr></table>

<p>
<div id="stdout"></div>

</body>
</html>
